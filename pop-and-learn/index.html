<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Pop & Learn ABCs</title>
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
    <style>
        :root {
            --bg-color: #e0f7fa;
            --balloon-color: #ff5252;
            --bubble-color: rgba(174, 234, 255, 0.6);
        }

        html {
            font-size: 1.5vmin;
        }

        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(to top, 
                #FFE5B4 0%,
                #FFB347 20%,
                #FF9A8B 40%,
                #FF6FA0 60%,
                #87CEEB 80%,
                #B0E0E6 100%);
            background-attachment: fixed;
            background-size: 100% 100%;
            user-select: none;
            touch-action: manipulation;
            position: fixed;
            width: 100%;
            height: 100%;
        }

        #game-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 5;
            cursor: pointer;
        }

        /* Start Screen */
        #start-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(to top, 
                #FFE5B4 0%,
                #FFB347 20%,
                #FF9A8B 40%,
                #FF6FA0 60%,
                #87CEEB 80%,
                #B0E0E6 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        #start-screen.hidden {
            display: none;
        }

        #start-screen h1 {
            font-size: 4.5rem;
            color: #0277bd;
            margin-bottom: 2rem;
            text-shadow: 0.2rem 0.2rem 0.4rem rgba(0,0,0,0.2);
        }

        .start-buttons {
            display: flex;
            flex-direction: column;
            gap: 1.25rem;
        }

        .start-button {
            padding: 1.25rem 3.75rem;
            font-size: 1.5rem;
            border-radius: 1.875rem;
            border: none;
            background: #4fc3f7;
            color: white;
            cursor: pointer;
            font-weight: bold;
            box-shadow: 0 0.375rem 1.25rem rgba(0,0,0,0.2);
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .start-button:hover {
            transform: translateY(-0.2rem);
            box-shadow: 0 0.5rem 1.5rem rgba(0,0,0,0.3);
        }

        .start-button:active {
            transform: translateY(0);
            box-shadow: 0 0.25rem 1rem rgba(0,0,0,0.2);
        }

        .start-button.secondary {
            background: #ff9800;
        }

        .start-button.disabled {
            background: #ccc;
            cursor: not-allowed;
            opacity: 0.6;
        }

        .start-button.disabled:hover {
            transform: none;
            box-shadow: 0 0.375rem 1.25rem rgba(0,0,0,0.2);
        }

        /* Player Selection Styles */
        .player-section {
            text-align: center;
        }

        .player-section h2 {
            color: #0277bd;
            font-size: 2rem;
            margin-bottom: 1.5rem;
        }

        #welcome-message {
            color: #0277bd;
            font-size: 2rem;
            margin-bottom: 1.5rem;
        }

        .existing-players {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            justify-content: center;
            margin-bottom: 2rem;
            max-width: 600px;
        }

        .player-button {
            padding: 15px 30px;
            font-size: 1.3rem;
            border-radius: 25px;
            border: 3px solid #4fc3f7;
            background: white;
            color: #0277bd;
            cursor: pointer;
            font-weight: bold;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            transition: all 0.2s;
        }

        .player-button:hover {
            background: #4fc3f7;
            color: white;
            transform: translateY(-0.2rem);
            box-shadow: 0 0.375rem 1.25rem rgba(0,0,0,0.3);
        }

        .name-input-section {
            display: flex;
            flex-direction: column;
            gap: 0.9rem;
            align-items: center;
        }

        #player-name-input {
            padding: 0.9rem 1.5rem;
            font-size: 1.3rem;
            border-radius: 1.5rem;
            border: 0.2rem solid #4fc3f7;
            text-align: center;
            font-weight: bold;
            width: 18.75rem;
        }

        #player-name-input:focus {
            outline: none;
            border-color: #ff9800;
            box-shadow: 0 0 0.625rem rgba(79, 195, 247, 0.5);
        }

        #player-name-input.error {
            border-color: #f44336;
            animation: input-shake 0.5s;
        }

        @keyframes input-shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-10px); }
            75% { transform: translateX(10px); }
        }

        #ui-layer {
            position: absolute;
            top: 1.25rem;
            width: 100%;
            text-align: center;
            z-index: 100;
            pointer-events: none;
        }

        .instruction-card {
            background: white;
            padding: 1rem 2rem;
            border-radius: 3rem;
            display: inline-block;
            box-shadow: 0 0.5rem 1.25rem rgba(0,0,0,0.1);
            border: 0.25rem solid #4fc3f7;
            pointer-events: auto;
        }

        h1 { margin: 0; color: #0277bd; font-size: 2rem; }
        #target-display { font-weight: bold; color: #e91e63; font-size: 2.5rem; }

        #controls-toggle {
            position: fixed;
            bottom: 1rem;
            right: 1rem;
            width: 4rem;
            height: 4rem;
            border-radius: 50%;
            background: #ff9800;
            border: 0.25rem solid white;
            color: white;
            font-size: 2rem;
            cursor: pointer;
            z-index: 150;
            box-shadow: 0 0.5rem 1.5rem rgba(0,0,0,0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.2s;
        }

        #controls-toggle:active {
            transform: scale(0.9);
        }

        .controls {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            z-index: 140;
            display: flex;
            flex-direction: column;
            gap: 1rem;
            padding: 1.5rem;
            background: rgba(255, 255, 255, 0.98);
            border-top: 0.3rem solid #4fc3f7;
            box-shadow: 0 -0.5rem 2rem rgba(0,0,0,0.3);
            transform: translateY(100%);
            transition: transform 0.3s ease-in-out;
            max-height: 60vh;
            overflow-y: auto;
        }

        .controls.open {
            transform: translateY(0);
        }

        .controls-row {
            display: flex;
            flex-wrap: wrap;
            gap: 0.75rem;
            justify-content: center;
        }

        button {
            padding: 2rem 4rem;
            font-size: 2.4rem;
            border-radius: 2rem;
            border: none;
            background: #4fc3f7;
            color: white;
            cursor: pointer;
            font-weight: bold;
            white-space: nowrap;
            flex-shrink: 0;
            min-height: 7rem;
            touch-action: manipulation;
        }

        button:active { transform: scale(0.95); }

        @media (max-width: 768px) {
            /* Mobile-specific adjustments only if needed */
        }

        @media (max-width: 915px) and (orientation: landscape) {
            /* Landscape-specific adjustments only if needed */
        }

        /* No CSS animations - using JS loop like raptor game */

        /* Game Objects */
        .game-object {
            position: absolute;
            bottom: 0px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            font-weight: bold;
            font-size: 3rem;
            color: #333;
            text-shadow: 0.06rem 0.06rem 0.125rem rgba(255,255,255,0.8);
            will-change: transform;
            transform: translate3d(0, 0, 0);
            z-index: 10;
            backface-visibility: hidden;
            perspective: 1000px;
            contain: layout style paint;
            pointer-events: auto;
        }

        /* Balloon Style */
        .balloon {
            width: 10rem;
            height: 12.5rem;
            border-radius: 50% 50% 50% 50% / 40% 40% 60% 60%;
            background-color: var(--balloon-color);
            background: radial-gradient(circle at 30% 30%, 
                rgba(255, 255, 255, 0.6), 
                var(--balloon-color) 60%);
            box-shadow: 0 0.3rem 0.8rem rgba(0,0,0,0.3);
            position: relative;
        }
        .balloon::before {
            content: "";
            position: absolute;
            top: 15%;
            left: 20%;
            width: 30%;
            height: 35%;
            background: rgba(255, 255, 255, 0.4);
            border-radius: 50%;
            filter: blur(0.2rem);
        }

        /* Bubble Style */
        .bubble {
            width: 11rem;
            height: 11rem;
            background: radial-gradient(circle at 35% 35%, 
                rgba(255, 255, 255, 0.9), 
                rgba(100, 200, 255, 0.6) 60%);
            border-radius: 50%;
            border: 0.2rem solid rgba(255, 255, 255, 0.9);
            box-shadow: 0 0 0.8rem rgba(100, 200, 255, 0.5);
            position: relative;
        }
        .bubble::before {
            content: "";
            position: absolute;
            top: 15%;
            left: 25%;
            width: 30%;
            height: 30%;
            background: rgba(255, 255, 255, 0.7);
            border-radius: 50%;
            filter: blur(0.125rem);
        }
        .bubble::after {
            content: "";
            position: absolute;
            bottom: 20%;
            right: 25%;
            width: 15%;
            height: 15%;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            filter: blur(0.06rem);
        }
        
        @keyframes bubble-shimmer {
            0% { filter: brightness(1); }
            100% { filter: brightness(1.15); }
        }

        /* Floating Shape Style */
        .floating-shape {
            font-size: 6rem;
            filter: drop-shadow(0 0.3rem 1rem rgba(0,0,0,0.3));
            z-index: 10;
        }

        .pop-effect {
            animation: pop 0.3s forwards;
        }

        @keyframes pop {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.5); opacity: 0.5; }
            100% { transform: scale(0); opacity: 0; }
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-10px); }
            75% { transform: translateX(10px); }
        }

        .shake-effect {
            animation: shake 0.3s;
        }

        /* Particles */
        .particle {
            position: absolute;
            pointer-events: none;
            border-radius: 50%;
            animation: particle-float 1s forwards;
            will-change: transform, opacity;
            backface-visibility: hidden;
        }

        @keyframes particle-float {
            0% { transform: translate(0, 0) scale(1); opacity: 1; }
            100% { transform: translate(var(--tx), var(--ty)) scale(0); opacity: 0; }
        }

        /* Confetti */
        .confetti {
            position: absolute;
            width: 0.625rem;
            height: 0.625rem;
            pointer-events: none;
            animation: confetti-fall 2s forwards;
            will-change: transform, opacity;
            backface-visibility: hidden;
        }

        @keyframes confetti-fall {
            0% { transform: translateY(0) rotate(0deg); opacity: 1; }
            100% { transform: translateY(100vh) rotate(720deg); opacity: 0; }
        }

        /* Streak display */
        .streak-display {
            position: absolute;
            top: 6rem;
            right: 1.25rem;
            background: white;
            padding: 1rem 1.5rem;
            border-radius: 1.25rem;
            box-shadow: 0 0.25rem 1rem rgba(0,0,0,0.1);
            border: 0.2rem solid #4caf50;
            font-size: 1.5rem;
            font-weight: bold;
            color: #4caf50;
            z-index: 100;
            transition: transform 0.3s;
        }

        .streak-display.pulse {
            animation: pulse 0.5s;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.2); }
        }

        .celebration-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 4rem;
            font-weight: bold;
            color: #4caf50;
            text-shadow: 0.2rem 0.2rem 0.4rem rgba(0,0,0,0.3);
            pointer-events: none;
            animation: celebrate 1s forwards;
            z-index: 200;
        }

        @keyframes celebrate {
            0% { transform: translate(-50%, -50%) scale(0); opacity: 0; }
            50% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(0); opacity: 0; }
        }

        /* Lesson Items Display */
        .lesson-items {
            position: absolute;
            bottom: 11rem;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 0.9rem;
            background: white;
            padding: 1rem 1.5rem;
            border-radius: 1.5rem;
            box-shadow: 0 0.25rem 1rem rgba(0,0,0,0.2);
            border: 0.2rem solid #4fc3f7;
            z-index: 100;
        }

        .lesson-item {
            width: 3.75rem;
            height: 3.75rem;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.3rem;
            font-weight: bold;
            background: #e3f2fd;
            border-radius: 0.9rem;
            border: 0.125rem solid #4fc3f7;
            color: #0277bd;
            position: relative;
            transition: all 0.3s;
        }

        .lesson-item.completed {
            background: #c8e6c9;
            border-color: #4caf50;
            color: #2e7d32;
        }

        .lesson-item.completed::after {
            content: "‚úì";
            position: absolute;
            top: -0.3rem;
            right: -0.3rem;
            width: 1.5rem;
            height: 1.5rem;
            background: #4caf50;
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.9rem;
            font-weight: bold;
            box-shadow: 0 0.125rem 0.3rem rgba(0,0,0,0.3);
        }

        .color-block {
            width: 100%;
            height: 100%;
            border-radius: 0.625rem;
        }

        .balloon .color-block,
        .bubble .color-block {
            border-radius: 50%;
            width: 70%;
            height: 70%;
        }

        .background-target .color-block {
            width: 15rem;
            height: 15rem;
            border-radius: 1.875rem;
            border: 0.3rem solid;
            box-shadow: 0 0.5rem 1.25rem rgba(0, 0, 0, 0.3);
        }

        #target-display .color-block {
            display: inline-block;
            width: 2.5rem;
            height: 2.5rem;
            border-radius: 8px;
            vertical-align: middle;
            border: 2px solid white;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }

        .lesson-info {
            position: absolute;
            top: 6rem;
            left: 1.25rem;
            background: white;
            padding: 1rem 1.5rem;
            border-radius: 1.25rem;
            box-shadow: 0 0.25rem 1rem rgba(0,0,0,0.1);
            border: 0.2rem solid #ff9800;
            font-size: 1.2rem;
            font-weight: bold;
            color: #ff9800;
            z-index: 100;
        }

        .version-display {
            position: fixed;
            bottom: 1rem;
            left: 1rem;
            background: rgba(255, 255, 255, 0.9);
            padding: 0.5rem 1rem;
            border-radius: 0.75rem;
            box-shadow: 0 0.125rem 0.5rem rgba(0,0,0,0.1);
            font-size: 0.9rem;
            font-weight: bold;
            color: #666;
            z-index: 130;
        }

        /* Large Background Target Display */
        .background-target {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 18rem;
            font-weight: bold;
            color: transparent;
            -webkit-text-stroke: 0.2rem rgba(0, 0, 0, 0.2);
            text-stroke: 0.2rem rgba(0, 0, 0, 0.2);
            pointer-events: none;
            z-index: 1;
            text-align: center;
            user-select: none;
        }

        .background-target.shape-outline {
            color: transparent;
            -webkit-text-stroke: 0.3rem rgba(0, 0, 0, 0.4);
            text-stroke: 0.3rem rgba(0, 0, 0, 0.4);
            filter: drop-shadow(0 0.3rem 0.625rem rgba(0, 0, 0, 0.2));
            -webkit-text-fill-color: transparent;
        }
    </style>
</head>
<body>

<!-- Start Screen -->
<div id="start-screen">
    <h1>üéà Pop & Learn ABCs üéà</h1>
    
    <!-- Player Selection Section -->
    <div id="player-selection" class="player-section">
        <h2>Who's Playing?</h2>
        <div id="existing-players" class="existing-players">
            <!-- Existing player buttons will appear here -->
        </div>
        <div class="name-input-section">
            <input type="text" id="player-name-input" placeholder="Enter your name" maxlength="15">
            <button class="start-button" onclick="selectPlayer()">Start!</button>
        </div>
    </div>
    
    <!-- Game Start Buttons (hidden until player selected) -->
    <div id="game-start-buttons" class="start-buttons" style="display: none;">
        <h2 id="welcome-message">Welcome!</h2>
        <button class="start-button" onclick="startNewGame()">New Game</button>
        <button id="continue-button" class="start-button secondary" onclick="continueGame()">Continue</button>
        <button class="start-button" style="background: #999;" onclick="backToPlayerSelect()">‚Üê Back</button>
    </div>
</div>

<canvas id="game-canvas"></canvas>

<div class="background-target" id="background-target">?</div>

<div id="ui-layer">
    <div class="instruction-card">
        <h1>Pop the <span id="category-type">Letter</span> <span id="target-display">?</span></h1>
    </div>
</div>

<div class="lesson-info" id="lesson-info">
    üìö Lesson <span id="lesson-number">1</span>
</div>

<div class="streak-display" id="streak-display">
    üî• Streak: <span id="streak-count">0</span>
</div>

<div class="lesson-items" id="lesson-items">
    <!-- Lesson items will be populated here -->
</div>

<div class="version-display">v3.0.0 Canvas</div>

<!-- Toggle Button -->
<button id="controls-toggle" onclick="toggleControls()" aria-label="Toggle Controls">‚öôÔ∏è</button>

<!-- Controls Panel -->
<div class="controls" id="controls-panel">
    <div class="controls-row">
        <button onclick="returnToMenu()">üè† Menu</button>
        <button onclick="changeCategory()">üìö Mode: <span id="category-name">ABCs</span></button>
    </div>
    <div class="controls-row">
        <button onclick="prevLesson()">‚¨ÖÔ∏è Previous</button>
        <button onclick="nextLesson()">Next ‚û°Ô∏è</button>
    </div>
    <div class="controls-row">
        <button onclick="changeMode('balloons')">üéà Balloons</button>
        <button onclick="changeMode('bubbles')">ü´ß Bubbles</button>
    </div>
    <div class="controls-row">
        <button onclick="changeSpeed()">‚ö° Speed: <span id="speed-name">Normal</span></button>
    </div>
</div>

<script>
    const allCategories = {
        'ABCs': 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split(''),
        'Numbers': '0123456789'.split(''),
        'Colors': ['Red', 'Blue', 'Green', 'Yellow', 'Purple', 'Orange', 'Pink', 'Brown', 'Black', 'White'],
        'Shapes': ['‚óè', '‚ñ†', '‚ñ≤', '‚ñ¨', '‚¨≠', '‚¨ü', '‚¨¢', '‚¨£', '‚óÜ', '‚òÖ', '‚ñÆ', '‚äø', '‚óä', '‚ñ∞', '‚¨¨']
    };

    const speedSettings = {
        'Slow': { interval: 1000, speed: 0.8 },
        'Normal': { interval: 700, speed: 1.5 },
        'Fast': { interval: 500, speed: 2.5 }
    };

    const encouragements = ['Great!', 'Awesome!', 'Perfect!', 'Amazing!', 'Fantastic!', 'Wonderful!', 'Excellent!'];
    const tryAgainMessages = ['Keep Trying!', 'Try Again!', 'You Can Do It!', 'Almost!', 'Keep Going!', 'Nice Try!', 'So Close!'];

    let currentCategoryKeys = Object.keys(allCategories);
    let categoryIndex = 0;
    let currentLesson = 0;
    let itemsPerLesson = 5;
    let currentMode = 'balloons';
    let targetValue = '';
    let streak = 0;
    let speedKeys = Object.keys(speedSettings);
    let speedIndex = 1; // Start at Normal
    let spawnInterval;
    let completedItems = new Set(); // Track completed items in current lesson
    let activeObjectCount = 0; // Track active objects efficiently
    let gameObjects = []; // Array to track all active objects for single animation loop
    let masterAnimationId = null; // Single master animation loop
    
    // Canvas setup
    const canvas = document.getElementById('game-canvas');
    const ctx = canvas.getContext('2d');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    
    // Resize canvas on window resize
    window.addEventListener('resize', () => {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    });
    
    const targetDisplay = document.getElementById('target-display');
    const backgroundTarget = document.getElementById('background-target');
    const categoryTypeDisplay = document.getElementById('category-type');
    const categoryNameDisplay = document.getElementById('category-name');
    const streakCount = document.getElementById('streak-count');
    const streakDisplay = document.getElementById('streak-display');
    const speedNameDisplay = document.getElementById('speed-name');
    const lessonItemsContainer = document.getElementById('lesson-items');
    const lessonNumberDisplay = document.getElementById('lesson-number');

    const categoryTypes = {
        'ABCs': 'Letter',
        'Numbers': 'Number',
        'Colors': 'Color',
        'Shapes': 'Shape'
    };

    // Audio Context for sound effects
    let audioContext;
    try {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
    } catch (e) {
        console.warn('Audio context not available:', e);
    }

    function getCurrentLessonItems() {
        const allItems = allCategories[currentCategoryKeys[categoryIndex]];
        const startIndex = currentLesson * itemsPerLesson;
        const endIndex = Math.min(startIndex + itemsPerLesson, allItems.length);
        return allItems.slice(startIndex, endIndex);
    }

    function getMaxLessons() {
        const allItems = allCategories[currentCategoryKeys[categoryIndex]];
        return Math.ceil(allItems.length / itemsPerLesson);
    }

    function updateLessonDisplay() {
        const items = getCurrentLessonItems();
        lessonItemsContainer.innerHTML = '';
        
        items.forEach(item => {
            const itemDiv = document.createElement('div');
            itemDiv.className = 'lesson-item';
            if (completedItems.has(item)) {
                itemDiv.classList.add('completed');
            }
            
            if(currentCategoryKeys[categoryIndex] === 'Colors') {
                const colorBlock = document.createElement('div');
                colorBlock.className = 'color-block';
                colorBlock.style.backgroundColor = item.toLowerCase();
                itemDiv.appendChild(colorBlock);
            } else {
                itemDiv.innerText = item;
            }
            
            lessonItemsContainer.appendChild(itemDiv);
        });
        
        lessonNumberDisplay.innerText = currentLesson + 1;
    }

    function nextLesson() {
        const maxLessons = getMaxLessons();
        currentLesson = (currentLesson + 1) % maxLessons;
        completedItems.clear();
        // Clear all objects from previous lesson
        gameObjects = [];
        activeObjectCount = 0;
        updateLessonDisplay();
        updateTarget();
        streak = 0;
        streakCount.innerText = streak;
        saveProgress();
    }

    function prevLesson() {
        const maxLessons = getMaxLessons();
        currentLesson = (currentLesson - 1 + maxLessons) % maxLessons;
        completedItems.clear();
        // Clear all objects from previous lesson
        gameObjects = [];
        activeObjectCount = 0;
        updateLessonDisplay();
        updateTarget();
        streak = 0;
        streakCount.innerText = streak;
        saveProgress();
    }

    function playPopSound() {
        if (!audioContext) return;
        try {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.value = 800;
            oscillator.type = 'sine';
            
            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.1);
        } catch (e) {
            console.warn('Audio error:', e);
        }
    }

    function playWrongSound() {
        if (!audioContext) return;
        try {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.value = 200;
            oscillator.type = 'sawtooth';
            
            gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.15);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.15);
        } catch (e) {
            console.warn('Audio error:', e);
        }
    }

    function playCelebrationSound() {
        if (!audioContext) return;
        try {
            const frequencies = [523, 659, 784, 1047];
            frequencies.forEach((freq, i) => {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.value = freq;
                oscillator.type = 'sine';
                
                const startTime = audioContext.currentTime + (i * 0.1);
                gainNode.gain.setValueAtTime(0.15, startTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, startTime + 0.2);
                
                oscillator.start(startTime);
                oscillator.stop(startTime + 0.2);
            });
        } catch (e) {
            console.warn('Audio error:', e);
        }
    }

    function createParticles(x, y, color) {
        for (let i = 0; i < 5; i++) {
            const particle = document.createElement('div');
            particle.className = 'particle';
            particle.style.left = x + 'px';
            particle.style.top = y + 'px';
            particle.style.backgroundColor = color;
            particle.style.width = (5 + Math.random() * 10) + 'px';
            particle.style.height = particle.style.width;
            
            const angle = (Math.PI * 2 * i) / 8;
            const distance = 50 + Math.random() * 100;
            particle.style.setProperty('--tx', Math.cos(angle) * distance + 'px');
            particle.style.setProperty('--ty', Math.sin(angle) * distance + 'px');
            
            document.body.appendChild(particle);
            setTimeout(() => particle.remove(), 1000);
        }
    }

    function createConfetti(x, y) {
        const colors = ['#ff5252', '#448aff', '#4caf50', '#ffeb3b', '#e040fb', '#ff9800'];
        for (let i = 0; i < 10; i++) {
            const confetti = document.createElement('div');
            confetti.className = 'confetti';
            confetti.style.left = x + (Math.random() * 200 - 100) + 'px';
            confetti.style.top = y + 'px';
            confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
            confetti.style.animationDelay = Math.random() * 0.3 + 's';
            confetti.style.animationDuration = (1 + Math.random()) + 's';
            
            document.body.appendChild(confetti);
            setTimeout(() => confetti.remove(), 2500);
        }
    }

    function showCelebrationText(text, x, y) {
        const celebText = document.createElement('div');
        celebText.className = 'celebration-text';
        celebText.innerText = text;
        celebText.style.left = x + 'px';
        celebText.style.top = y + 'px';
        document.body.appendChild(celebText);
        setTimeout(() => celebText.remove(), 1000);
    }

    function updateStreak(correct) {
        if (correct) {
            streak++;
            streakCount.innerText = streak;
            streakDisplay.classList.add('pulse');
            setTimeout(() => streakDisplay.classList.remove('pulse'), 500);
            
            // Extra celebration at milestones
            if (streak % 5 === 0 && streak > 0) {
                playCelebrationSound();
                createConfetti(window.innerWidth / 2, 100);
            }
        } else {
            streak = 0;
            streakCount.innerText = streak;
        }
    }

    function initGame() {
        // Update UI displays based on current state
        categoryNameDisplay.innerText = currentCategoryKeys[categoryIndex];
        speedNameDisplay.innerText = speedKeys[speedIndex];
        streakCount.innerText = streak;
        
        // Clear animation tracking
        gameObjects = [];
        if (masterAnimationId) {
            cancelAnimationFrame(masterAnimationId);
            masterAnimationId = null;
        }
        
        updateLessonDisplay();
        updateTarget();
        startMasterAnimationLoop(); // Single loop handles both spawn and animation
        
        // Keyboard support
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                // Clear all objects
                document.querySelectorAll('.game-object').forEach(obj => obj.remove());
            }
        });
    }

    let currentShapeColor = '#e91e63'; // Store current shape color
    let currentPlayer = null; // Current player name

    // Player Management Functions
    function getAllPlayers() {
        const playersData = localStorage.getItem('popAndLearnPlayers');
        return playersData ? JSON.parse(playersData) : [];
    }

    function savePlayersList(players) {
        localStorage.setItem('popAndLearnPlayers', JSON.stringify(players));
    }

    function selectPlayer() {
        const nameInput = document.getElementById('player-name-input');
        const name = nameInput.value.trim();
        
        console.log('selectPlayer called with name:', name);
        
        if (!name) {
            nameInput.placeholder = 'Please enter your name!';
            nameInput.classList.add('error');
            setTimeout(() => {
                nameInput.placeholder = 'Enter your name';
                nameInput.classList.remove('error');
            }, 2000);
            return;
        }
        
        currentPlayer = name;
        
        // Add to players list if new
        const players = getAllPlayers();
        if (!players.includes(name)) {
            players.push(name);
            savePlayersList(players);
        }
        
        showGameStartButtons();
    }

    function selectExistingPlayer(name) {
        currentPlayer = name;
        showGameStartButtons();
    }

    function showGameStartButtons() {
        document.getElementById('player-selection').style.display = 'none';
        document.getElementById('game-start-buttons').style.display = 'flex';
        document.getElementById('welcome-message').innerText = `Welcome, ${currentPlayer}! üéâ`;
        
        // Check if this player has saved progress
        const continueButton = document.getElementById('continue-button');
        if (!hasPlayerProgress(currentPlayer)) {
            continueButton.classList.add('disabled');
            continueButton.onclick = null;
        } else {
            continueButton.classList.remove('disabled');
            continueButton.onclick = continueGame;
        }
    }

    function backToPlayerSelect() {
        document.getElementById('game-start-buttons').style.display = 'none';
        document.getElementById('player-selection').style.display = 'block';
        document.getElementById('player-name-input').value = '';
        currentPlayer = null;
    }

    function loadExistingPlayers() {
        const players = getAllPlayers();
        const container = document.getElementById('existing-players');
        container.innerHTML = '';
        
        if (players.length > 0) {
            players.forEach(player => {
                const button = document.createElement('button');
                button.className = 'player-button';
                button.textContent = player;
                button.onclick = () => selectExistingPlayer(player);
                container.appendChild(button);
            });
        }
    }

    // Save/Load Functions (updated for per-player saves)
    function getPlayerKey() {
        return `popAndLearnProgress_${currentPlayer}`;
    }

    function saveProgress() {
        if (!currentPlayer) return;
        
        const progress = {
            categoryIndex: categoryIndex,
            currentLesson: currentLesson,
            completedItems: Array.from(completedItems),
            streak: streak,
            currentMode: currentMode,
            speedIndex: speedIndex
        };
        localStorage.setItem(getPlayerKey(), JSON.stringify(progress));
    }

    function loadProgress() {
        if (!currentPlayer) return null;
        
        const saved = localStorage.getItem(getPlayerKey());
        if (saved) {
            return JSON.parse(saved);
        }
        return null;
    }

    function hasPlayerProgress(playerName) {
        const key = `popAndLearnProgress_${playerName}`;
        return localStorage.getItem(key) !== null;
    }

    function hasSavedProgress() {
        return hasPlayerProgress(currentPlayer);
    }

    function startNewGame() {
        console.log('startNewGame called, currentPlayer:', currentPlayer);
        if (!currentPlayer) return;
        
        // Resume audio context on user interaction
        if (audioContext && audioContext.state === 'suspended') {
            audioContext.resume();
        }
        
        // Clear saved progress for this player
        localStorage.removeItem(getPlayerKey());
        // Reset game state
        categoryIndex = 0;
        currentLesson = 0;
        completedItems.clear();
        streak = 0;
        speedIndex = 1;
        currentMode = 'balloons';
        // Hide start screen and start game
        document.getElementById('start-screen').classList.add('hidden');
        console.log('Calling initGame...');
        initGame();
        console.log('Game initialized');
    }

    function continueGame() {
        // Resume audio context on user interaction
        if (audioContext && audioContext.state === 'suspended') {
            audioContext.resume();
        }
        
        const progress = loadProgress();
        if (progress) {
            categoryIndex = progress.categoryIndex || 0;
            currentLesson = progress.currentLesson || 0;
            completedItems = new Set(progress.completedItems || []);
            streak = progress.streak || 0;
            currentMode = progress.currentMode || 'balloons';
            speedIndex = progress.speedIndex || 1;
        }
        // Hide start screen and start game
        document.getElementById('start-screen').classList.add('hidden');
        initGame();
    }

    // Check for saved progress on load
    window.addEventListener('DOMContentLoaded', () => {
        loadExistingPlayers();
    });

    function updateTarget() {
        const items = getCurrentLessonItems();
        
        // Only pick from items not yet completed
        const remainingItems = items.filter(item => !completedItems.has(item));
        
        // If all items completed, this will be called from showLessonComplete anyway
        if (remainingItems.length === 0) return;
        
        targetValue = remainingItems[Math.floor(Math.random() * remainingItems.length)];
        
        // Update category type text
        const categoryName = currentCategoryKeys[categoryIndex];
        
        if(categoryName === 'Shapes') {
            // For shapes, show "Shape" plus the shape character
            categoryTypeDisplay.innerText = 'Shape';
            // Pick random color for this shape
            const shapeColors = ['#ff5252', '#448aff', '#4caf50', '#ffeb3b', '#e040fb', '#ff9800'];
            currentShapeColor = shapeColors[Math.floor(Math.random() * shapeColors.length)];
            targetDisplay.innerText = targetValue;
            backgroundTarget.innerText = targetValue;
            backgroundTarget.classList.add('shape-outline');
            targetDisplay.style.color = currentShapeColor;
            backgroundTarget.style.color = currentShapeColor;
        } else {
            categoryTypeDisplay.innerText = categoryTypes[categoryName];
        }
        
        if(categoryName === 'Colors') {
            // Show color block instead of text
            targetDisplay.innerHTML = `<div class="color-block" style="background-color: ${targetValue.toLowerCase()};"></div>`;
            const bgColorBlock = document.createElement('div');
            bgColorBlock.className = 'color-block';
            bgColorBlock.style.borderColor = targetValue.toLowerCase();
            bgColorBlock.style.backgroundColor = `rgba(${hexToRgb(targetValue.toLowerCase())}, 0.6)`; // 60% opacity fill
            backgroundTarget.innerHTML = '';
            backgroundTarget.classList.remove('shape-outline');
            backgroundTarget.appendChild(bgColorBlock);
        } else if(categoryName !== 'Shapes') {
            targetDisplay.innerText = targetValue;
            backgroundTarget.innerText = targetValue;
            backgroundTarget.classList.remove('shape-outline');
            targetDisplay.style.color = '#e91e63';
        }
    }

    function hexToRgb(colorName) {
        const colors = {
            'red': '255, 0, 0',
            'blue': '0, 0, 255',
            'green': '0, 128, 0',
            'yellow': '255, 255, 0',
            'purple': '128, 0, 128',
            'orange': '255, 165, 0',
            'pink': '255, 192, 203',
            'brown': '165, 42, 42',
            'black': '0, 0, 0',
            'white': '255, 255, 255'
        };
        return colors[colorName] || '0, 0, 0';
    }

    function hexToRgb(colorName) {
        const colors = {
            'red': '255, 0, 0',
            'blue': '0, 0, 255',
            'green': '0, 128, 0',
            'yellow': '255, 255, 0',
            'purple': '128, 0, 128',
            'orange': '255, 165, 0',
            'pink': '255, 192, 203',
            'brown': '165, 42, 42',
            'black': '0, 0, 0',
            'white': '255, 255, 255'
        };
        return colors[colorName] || '0, 0, 0';
    }

    function spawnObject() {
        const items = getCurrentLessonItems();
        
        // 40% chance to spawn the target item for balanced gameplay
        let randomValue;
        if (Math.random() < 0.4) {
            randomValue = targetValue;
        } else {
            randomValue = items[Math.floor(Math.random() * items.length)];
        }
        
        // Calculate rem size
        const vmin = Math.min(window.innerWidth, window.innerHeight) / 100;
        const remInPx = 1.5 * vmin;
        const size = currentMode === 'balloons' ? 10 * remInPx : 11 * remInPx;
        
        // Random horizontal position
        const screenWidth = window.innerWidth;
        const maxX = screenWidth - size;
        const startX = Math.floor(Math.random() * Math.max(0, maxX));
        
        // Get speed
        const speedName = speedKeys[speedIndex];
        const speeds = { 'Slow': 0.4, 'Normal': 0.7, 'Fast': 1.2 };
        const speedY = speeds[speedName];
        
        // Random color
        const colors = ['#ff5252', '#448aff', '#4caf50', '#ffeb3b', '#e040fb', '#ff9800'];
        let objColor;
        
        if(currentCategoryKeys[categoryIndex] === 'Colors') {
            // Convert color name to hex
            const colorMap = {
                'red': '#ff0000',
                'blue': '#0000ff',
                'green': '#00ff00',
                'yellow': '#ffff00',
                'purple': '#800080',
                'orange': '#ffa500',
                'pink': '#ffc0cb',
                'brown': '#a52a2a',
                'black': '#000000',
                'white': '#ffffff'
            };
            objColor = colorMap[randomValue.toLowerCase()] || '#ff5252';
        } else if(currentCategoryKeys[categoryIndex] === 'Shapes') {
            if(randomValue === targetValue) {
                objColor = currentShapeColor;
            } else {
                objColor = colors[Math.floor(Math.random() * colors.length)];
            }
        } else {
            objColor = colors[Math.floor(Math.random() * colors.length)];
        }
        
        // Create game object
        const obj = {
            x: startX,
            y: window.innerHeight, // Start at bottom
            size: size,
            speedY: speedY,
            value: randomValue,
            color: objColor,
            type: currentMode,
            isShape: currentCategoryKeys[categoryIndex] === 'Shapes'
        };
        
        gameObjects.push(obj);
        activeObjectCount++;
    }
    
    // Draw balloon on canvas
    function drawBalloon(x, y, size, color) {
        const width = size;
        const height = size * 1.25;
        
        ctx.save();
        
        // Shadow behind balloon
        ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
        ctx.shadowBlur = 15;
        ctx.shadowOffsetX = 5;
        ctx.shadowOffsetY = 5;
        
        // Main balloon body - more realistic oval shape
        ctx.beginPath();
        ctx.ellipse(x + width/2, y + height/2.2, width/2, height/2, 0, 0, Math.PI * 2);
        
        // Multi-stop gradient for realistic 3D effect
        const gradient = ctx.createRadialGradient(
            x + width*0.35, y + height*0.25, 0,
            x + width/2, y + height/2, width*0.7
        );
        gradient.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
        gradient.addColorStop(0.3, color);
        gradient.addColorStop(0.7, color);
        // Darker edge for depth
        const darkerColor = adjustBrightness(color, -30);
        gradient.addColorStop(1, darkerColor);
        ctx.fillStyle = gradient;
        ctx.fill();
        
        // Remove shadow for overlays
        ctx.shadowColor = 'transparent';
        ctx.shadowBlur = 0;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 0;
        
        // Main highlight/shine
        ctx.beginPath();
        ctx.ellipse(x + width*0.3, y + height*0.2, width*0.18, height*0.14, -0.3, 0, Math.PI * 2);
        const highlightGradient = ctx.createRadialGradient(
            x + width*0.3, y + height*0.2, 0,
            x + width*0.3, y + height*0.2, width*0.18
        );
        highlightGradient.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
        highlightGradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.5)');
        highlightGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
        ctx.fillStyle = highlightGradient;
        ctx.fill();
        
        // Secondary highlight
        ctx.beginPath();
        ctx.ellipse(x + width*0.7, y + height*0.35, width*0.08, height*0.06, 0.3, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
        ctx.fill();
        
        // Subtle rim light on left edge
        ctx.beginPath();
        ctx.ellipse(x + width*0.15, y + height*0.45, width*0.05, height*0.2, 0, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
        ctx.fill();
        
        // Balloon knot at bottom
        ctx.beginPath();
        ctx.ellipse(x + width/2, y + height*0.95, width*0.08, height*0.04, 0, 0, Math.PI * 2);
        ctx.fillStyle = darkerColor;
        ctx.fill();
        
        // Balloon string - curved and realistic
        ctx.strokeStyle = 'rgba(200, 200, 200, 0.8)';
        ctx.lineWidth = 2;
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.moveTo(x + width/2, y + height);
        // Wavy string
        ctx.bezierCurveTo(
            x + width/2 - 10, y + height + 15,
            x + width/2 + 15, y + height + 25,
            x + width/2, y + height + 40
        );
        ctx.stroke();
        
        ctx.restore();
    }
    
    // Helper function to adjust color brightness
    function adjustBrightness(color, amount) {
        // Convert hex to RGB
        let r, g, b;
        if (color.startsWith('#')) {
            const hex = color.slice(1);
            r = parseInt(hex.substr(0, 2), 16);
            g = parseInt(hex.substr(2, 2), 16);
            b = parseInt(hex.substr(4, 2), 16);
        } else {
            return color;
        }
        
        // Adjust brightness
        r = Math.max(0, Math.min(255, r + amount));
        g = Math.max(0, Math.min(255, g + amount));
        b = Math.max(0, Math.min(255, b + amount));
        
        // Convert back to hex
        return '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
    }
    
    // Draw bubble on canvas
    function drawBubble(x, y, size, color) {
        ctx.save();
        
        // Main bubble circle
        ctx.beginPath();
        ctx.arc(x + size/2, y + size/2, size/2, 0, Math.PI * 2);
        
        // Gradient fill for transparency effect
        const gradient = ctx.createRadialGradient(x + size*0.3, y + size*0.3, 0, x + size/2, y + size/2, size/2);
        gradient.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
        gradient.addColorStop(0.4, color + '80'); // Add transparency
        gradient.addColorStop(1, color + '40');
        ctx.fillStyle = gradient;
        ctx.fill();
        
        // Outer border
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
        ctx.lineWidth = 3;
        ctx.stroke();
        
        // Highlight spots
        ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
        ctx.beginPath();
        ctx.arc(x + size*0.3, y + size*0.3, size*0.15, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
        ctx.beginPath();
        ctx.arc(x + size*0.7, y + size*0.6, size*0.08, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.restore();
    }
    
    // Draw text on object
    function drawText(obj) {
        // Colors mode: no text, just the color
        const currentCategory = currentCategoryKeys[categoryIndex];
        if(currentCategory === 'Colors') {
            return; // Don't draw any text
        }
        
        // Shapes mode: draw the shape emoji/symbol only
        if (obj.isShape) {
            ctx.save();
            ctx.fillStyle = obj.color;
            ctx.font = `bold ${obj.size * 0.5}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(obj.value, obj.x + obj.size/2, obj.y + obj.size/2);
            ctx.restore();
            return;
        }
        
        // Default: draw text (letters/numbers)
        ctx.save();
        ctx.fillStyle = '#333';
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 3;
        ctx.font = `bold ${obj.size * 0.3}px Arial`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.strokeText(obj.value, obj.x + obj.size/2, obj.y + obj.size/2);
        ctx.fillText(obj.value, obj.x + obj.size/2, obj.y + obj.size/2);
        ctx.restore();
    }
    
    // Draw realistic 3D shape
    function drawRealisticShape(x, y, size, color, shapeSymbol) {
        ctx.save();
        
        // Draw the main shape with gradient
        const gradient = ctx.createRadialGradient(
            x + size*0.35, y + size*0.35, 0,
            x + size/2, y + size/2, size*0.6
        );
        
        // Create gradient from light to dark
        const lightColor = adjustBrightness(color, 60);
        const darkColor = adjustBrightness(color, -30);
        
        gradient.addColorStop(0, lightColor);
        gradient.addColorStop(0.5, color);
        gradient.addColorStop(1, darkColor);
        
        ctx.fillStyle = gradient;
        ctx.font = `bold ${size * 0.8}px Arial`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(shapeSymbol, x + size/2, y + size/2);
        
        // Add highlight for 3D effect
        ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
        ctx.font = `bold ${size * 0.25}px Arial`;
        ctx.fillText(shapeSymbol, x + size*0.4, y + size*0.35);
        
        // Add subtle rim light
        ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
        ctx.font = `bold ${size * 0.15}px Arial`;
        ctx.fillText(shapeSymbol, x + size*0.3, y + size*0.4);
        
        ctx.restore();
    }
    
    function startMasterAnimationLoop() {
        let lastSpawnTime = performance.now();
        
        function masterLoop(currentTime) {
            // Handle spawning in same loop
            const currentSpeed = speedSettings[speedKeys[speedIndex]];
            const timeSinceLastSpawn = currentTime - lastSpawnTime;
            const spawnDelay = currentSpeed.interval + (Math.random() * 200 - 100);
            
            if (timeSinceLastSpawn >= spawnDelay) {
                spawnObject();
                lastSpawnTime = currentTime;
            }
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Update and draw all objects
            for (let i = gameObjects.length - 1; i >= 0; i--) {
                const obj = gameObjects[i];
                
                // Move up (negative Y = up)
                obj.y -= obj.speedY;
                
                // Draw object based on mode
                if (obj.isShape) {
                    // Shapes mode: draw realistic 3D shape
                    drawRealisticShape(obj.x, obj.y, obj.size, obj.color, obj.value);
                } else {
                    // Regular mode: draw balloon or bubble
                    if (obj.type === 'balloons') {
                        drawBalloon(obj.x, obj.y, obj.size, obj.color);
                    } else {
                        drawBubble(obj.x, obj.y, obj.size, obj.color);
                    }
                    // Draw text/value
                    drawText(obj);
                }
                
                // Remove if off screen (top)
                if (obj.y < -obj.size * 2) {
                    gameObjects.splice(i, 1);
                    activeObjectCount--;
                }
            }
            
            masterAnimationId = requestAnimationFrame(masterLoop);
        }
        
        masterAnimationId = requestAnimationFrame(masterLoop);
    }
    
    // Canvas click handling
    canvas.addEventListener('click', (e) => {
        const rect = canvas.getBoundingClientRect();
        const clickX = e.clientX - rect.left;
        const clickY = e.clientY - rect.top;
        
        // Check each object for click (iterate backwards to click topmost first)
        for (let i = gameObjects.length - 1; i >= 0; i--) {
            const obj = gameObjects[i];
            const size = obj.type === 'balloons' ? obj.size * 1.25 : obj.size;
            
            if (clickX >= obj.x && clickX <= obj.x + obj.size &&
                clickY >= obj.y && clickY <= obj.y + size) {
                handlePop(obj, i);
                break; // Only pop one object per click
            }
        }
    });
    
    canvas.addEventListener('touchend', (e) => {
        e.preventDefault();
        const rect = canvas.getBoundingClientRect();
        const touch = e.changedTouches[0];
        const clickX = touch.clientX - rect.left;
        const clickY = touch.clientY - rect.top;
        
        for (let i = gameObjects.length - 1; i >= 0; i--) {
            const obj = gameObjects[i];
            const size = obj.type === 'balloons' ? obj.size * 1.25 : obj.size;
            
            if (clickX >= obj.x && clickX <= obj.x + obj.size &&
                clickY >= obj.y && clickY <= obj.y + size) {
                handlePop(obj, i);
                break;
            }
        }
    });

    function handlePop(obj, index) {
        const value = obj.value;
        const color = obj.color;
        const x = obj.x + obj.size/2;
        const y = obj.y + obj.size/2;
        
        if (value === targetValue) {
            // Correct answer!
            playPopSound();
            createParticles(x, y, color);
            
            const encouragement = encouragements[Math.floor(Math.random() * encouragements.length)];
            showCelebrationText(encouragement, x, y);
            
            updateStreak(true);
            
            // Mark item as completed
            if (!completedItems.has(value)) {
                completedItems.add(value);
                updateLessonDisplay();
                saveProgress();
                
                // Check if lesson is complete
                const lessonItems = getCurrentLessonItems();
                if (completedItems.size === lessonItems.length) {
                    setTimeout(() => {
                        showLessonComplete();
                    }, 500);
                }
            }
            
            // Remove object from array immediately
            gameObjects.splice(index, 1);
            activeObjectCount--;
            updateTarget();
        } else {
            // Wrong answer - still pop it but show encouraging message!
            playPopSound(); // Still fun to pop!
            createParticles(x, y, color);
            
            const tryAgain = tryAgainMessages[Math.floor(Math.random() * tryAgainMessages.length)];
            showCelebrationText(tryAgain, x, y);
            
            updateStreak(false);
            
            // Remove the object so they can keep popping
            gameObjects.splice(index, 1);
            activeObjectCount--;
        }
    }

    function showLessonComplete() {
        playCelebrationSound();
        createConfetti(window.innerWidth / 2, window.innerHeight / 2);
        showCelebrationText('Lesson Complete! üéâ', window.innerWidth / 2, window.innerHeight / 2);
        
        // Close controls panel if open
        const panel = document.getElementById('controls-panel');
        panel.classList.remove('open');
        
        // Auto-advance to next lesson after 2 seconds
        setTimeout(() => {
            nextLesson();
        }, 2000);
    }

    function toggleControls() {
        const panel = document.getElementById('controls-panel');
        panel.classList.toggle('open');
    }

    function returnToMenu() {
        // Save progress
        saveProgress();
        // Stop spawning objects
        if (spawnInterval) {
            cancelAnimationFrame(spawnInterval);
            spawnInterval = null;
        }
        // Clear all existing objects
        document.querySelectorAll('.game-object').forEach(obj => obj.remove());
        // Show start screen with player selection
        document.getElementById('start-screen').classList.remove('hidden');
        document.getElementById('game-start-buttons').style.display = 'none';
        document.getElementById('player-selection').style.display = 'block';
        document.getElementById('player-name-input').value = '';
        // Reload player list in case there are new players
        loadExistingPlayers();
        // Reset current player
        currentPlayer = null;
    }

    function changeMode(mode) {
        currentMode = mode;
        saveProgress();
        toggleControls();
    }

    function changeCategory() {
        categoryIndex = (categoryIndex + 1) % currentCategoryKeys.length;
        categoryNameDisplay.innerText = currentCategoryKeys[categoryIndex];
        currentLesson = 0;
        completedItems.clear();
        // Clear all objects when changing category
        gameObjects = [];
        activeObjectCount = 0;
        updateLessonDisplay();
        updateTarget();
        streak = 0;
        streakCount.innerText = streak;
        saveProgress();
        toggleControls();
    }

    function changeSpeed() {
        speedIndex = (speedIndex + 1) % speedKeys.length;
        speedNameDisplay.innerText = speedKeys[speedIndex];
        startSpawning();
        saveProgress();
        toggleControls();
    }

    // Don't auto-start - wait for start screen
    // initGame() is now called by startNewGame() or continueGame()
</script>

</body>
</html>