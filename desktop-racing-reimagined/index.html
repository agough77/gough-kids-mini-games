<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Desktop Racing - Pole Position Style</title>
    <script async src="https://docs.opencv.org/4.x/opencv.js" type="text/javascript"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: 'Courier New', monospace;
            background: #000;
            color: #fff;
            overflow: hidden;
            user-select: none;
        }

        #gameCanvas {
            display: block;
            background: #87CEEB;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }

        #menu {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            padding: 20px;
        }

        #menu.hidden {
            display: none;
        }

        #menu h1 {
            font-size: clamp(2rem, 10vw, 5rem);
            color: #00ff00;
            text-shadow: 0 0 20px #00ff00, 0 0 40px #00ff00;
            margin-bottom: 2rem;
            animation: glow 2s infinite;
        }

        @keyframes glow {
            0%, 100% { text-shadow: 0 0 20px #00ff00, 0 0 40px #00ff00; }
            50% { text-shadow: 0 0 30px #00ff00, 0 0 60px #00ff00, 0 0 80px #00ff00; }
        }

        .menu-section {
            background: rgba(0,0,0,0.7);
            padding: 2rem;
            border-radius: 15px;
            margin-bottom: 1rem;
            border: 2px solid #00ff00;
            max-width: 90%;
        }

        .menu-section h2 {
            color: #00ff00;
            margin-bottom: 1rem;
            font-size: clamp(1.2rem, 5vw, 2rem);
        }

        #cameraSection {
            display: none;
        }

        #cameraSection.active {
            display: block;
        }

        #videoPreview {
            max-width: 100%;
            height: auto;
            border: 3px solid #00ff00;
            border-radius: 10px;
            margin: 1rem 0;
        }

        #cameraSelect {
            background: #000;
            color: #00ff00;
            border: 2px solid #00ff00;
            padding: 10px;
            font-family: 'Courier New', monospace;
            font-size: 1rem;
            border-radius: 5px;
            margin: 1rem 0;
            width: 100%;
        }

        .track-buttons {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 1rem;
            margin-top: 1rem;
        }

        button {
            background: linear-gradient(135deg, #00ff00 0%, #00cc00 100%);
            color: #000;
            border: 3px solid #00ff00;
            padding: 15px 30px;
            font-size: clamp(1rem, 4vw, 1.3rem);
            font-family: 'Courier New', monospace;
            font-weight: bold;
            cursor: pointer;
            border-radius: 10px;
            transition: all 0.3s;
            text-transform: uppercase;
            box-shadow: 0 0 20px rgba(0,255,0,0.3);
        }

        button:hover {
            background: linear-gradient(135deg, #00ff00 0%, #00ff00 100%);
            box-shadow: 0 0 30px rgba(0,255,0,0.8);
            transform: translateY(-2px);
        }

        button:active {
            transform: translateY(0);
        }

        #hud {
            position: fixed;
            top: 10px;
            left: 10px;
            right: 10px;
            z-index: 50;
            font-size: clamp(1rem, 4vw, 1.5rem);
            font-weight: bold;
            text-shadow: 2px 2px 4px #000;
            display: none;
        }

        #hud.active {
            display: block;
        }

        .hud-item {
            background: rgba(0,0,0,0.7);
            padding: 10px 20px;
            border-radius: 10px;
            display: inline-block;
            margin-right: 10px;
            margin-bottom: 10px;
            border: 2px solid #00ff00;
        }

        #pauseMenu {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.95);
            padding: 3rem;
            border-radius: 20px;
            border: 3px solid #00ff00;
            display: none;
            z-index: 200;
            text-align: center;
        }

        #pauseMenu.active {
            display: block;
        }

        #pauseMenu h2 {
            color: #00ff00;
            font-size: clamp(2rem, 8vw, 3rem);
            margin-bottom: 2rem;
        }

        #gameOver {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.95);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 300;
        }

        #gameOver.active {
            display: flex;
        }

        .game-over-content {
            text-align: center;
            padding: 2rem;
        }

        .game-over-content h2 {
            color: #00ff00;
            font-size: clamp(2rem, 10vw, 4rem);
            margin-bottom: 2rem;
            animation: glow 1s infinite;
        }

        .game-over-content .stats {
            font-size: clamp(1rem, 4vw, 1.5rem);
            margin-bottom: 2rem;
            color: #00ff00;
        }

        @media (max-width: 768px) {
            .menu-section {
                padding: 1rem;
            }
            
            .track-buttons {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div id="menu">
        <h1>üèéÔ∏è DESKTOP RACING üèéÔ∏è</h1>
        
        <div class="menu-section">
            <h2>SELECT TRACK</h2>
            <div class="track-buttons">
                <button onclick="showCameraMode()">üì∑ CAMERA TRACK</button>
                <button onclick="startGame('desert')">üèúÔ∏è DESERT HIGHWAY</button>
                <button onclick="startGame('city')">üèôÔ∏è CITY STREETS</button>
                <button onclick="startGame('mountain')">‚õ∞Ô∏è MOUNTAIN PASS</button>
                <button onclick="startGame('night')">üåÉ NIGHT CITY</button>
            </div>
        </div>

        <div class="menu-section" id="cameraSection">
            <h2>üì∑ CAMERA TRACK GENERATOR</h2>
            <p style="color: #00ff00; font-size: 0.9rem; margin-bottom: 1rem;">
                Place objects on your desk to create a custom racing track!
            </p>
            <select id="cameraSelect">
                <option>Loading cameras...</option>
            </select>
            <video id="videoPreview" autoplay playsinline style="display:none;"></video>
            <canvas id="processCanvas" style="display:none;"></canvas>
            <div class="track-buttons">
                <button onclick="processCamera()">GENERATE TRACK</button>
                <button onclick="hideCameraMode()">BACK</button>
            </div>
            <p id="cameraStatus" style="color: #00ff00; margin-top: 1rem; font-size: 0.9rem;"></p>
        </div>

        <div class="menu-section">
            <p style="color: #00ff00; font-size: clamp(0.9rem, 3vw, 1.1rem);">
                üéÆ USE ARROW KEYS OR TOUCH TO STEER<br>
                üèÅ AVOID TRAFFIC AND REACH THE FINISH LINE<br>
                ‚è∏Ô∏è PRESS ESC TO PAUSE
            </p>
        </div>
    </div>

    <div id="hud">
        <div class="hud-item">SPEED: <span id="speed">0</span> MPH</div>
        <div class="hud-item">DISTANCE: <span id="distance">0</span> M</div>
        <div class="hud-item">TIME: <span id="time">0:00</span></div>
    </div>

    <div id="pauseMenu">
        <h2>‚è∏Ô∏è PAUSED</h2>
        <button onclick="resumeGame()">RESUME</button>
        <button onclick="quitToMenu()">QUIT TO MENU</button>
    </div>

    <div id="gameOver">
        <div class="game-over-content">
            <h2>üèÅ RACE COMPLETE!</h2>
            <div class="stats">
                <p>TIME: <span id="finalTime">0:00</span></p>
                <p>TOP SPEED: <span id="finalSpeed">0</span> MPH</p>
                <p>DISTANCE: <span id="finalDistance">0</span> M</p>
            </div>
            <button onclick="quitToMenu()">BACK TO MENU</button>
            <button onclick="startGame(currentTrack)">RACE AGAIN</button>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Game state
        let gameRunning = false;
        let gamePaused = false;
        let currentTrack = 'desert';
        let playerX = 0.5; // 0 to 1 (left to right)
        let speed = 0;
        let maxSpeed = 200;
        let acceleration = 0.5;
        let deceleration = 0.3;
        let turnSpeed = 0.05;
        let roadPosition = 0;
        let distance = 0;
        let startTime = 0;
        let finishDistance = 5000;
        let cameraTrackData = null;
        
        // Camera variables
        let videoStream = null;
        let cameras = [];
        let opencvReady = false;
        
        // Road segments for 3D effect
        let roadSegments = [];
        const segmentLength = 200;
        const roadWidth = 2000;
        const cameraHeight = 1000;
        const cameraDepth = 1 / Math.tan((90 / 2) * Math.PI / 180);
        
        // Cars
        let cars = [];
        
        // Controls
        const keys = {};
        let touchX = null;
        
        // Resize canvas
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        // OpenCV initialization
        function onOpenCvReady() {
            opencvReady = true;
            console.log('OpenCV.js loaded');
        }
        
        // Wait for OpenCV
        if (typeof Module !== 'undefined') {
            Module.onRuntimeInitialized = onOpenCvReady;
        } else {
            window.Module = {
                onRuntimeInitialized: onOpenCvReady
            };
        }
        
        // Camera functions
        async function setupCamera() {
            try {
                await navigator.mediaDevices.getUserMedia({ video: true });
                const devices = await navigator.mediaDevices.enumerateDevices();
                cameras = devices.filter(d => d.kind === 'videoinput');
                
                const select = document.getElementById('cameraSelect');
                select.innerHTML = cameras.map((cam, i) => 
                    `<option value="${cam.deviceId}">${cam.label || `Camera ${i + 1}`}</option>`
                ).join('');
                
                if (cameras.length > 0) {
                    await switchCamera(cameras[0].deviceId);
                }
            } catch (err) {
                document.getElementById('cameraStatus').textContent = '‚ùå Camera access denied';
            }
        }
        
        async function switchCamera(deviceId) {
            if (videoStream) {
                videoStream.getTracks().forEach(track => track.stop());
            }
            
            try {
                videoStream = await navigator.mediaDevices.getUserMedia({
                    video: { deviceId: { exact: deviceId }, width: 640, height: 480 }
                });
                const video = document.getElementById('videoPreview');
                video.srcObject = videoStream;
                video.style.display = 'block';
            } catch (err) {
                console.error('Camera error:', err);
            }
        }
        
        document.getElementById('cameraSelect')?.addEventListener('change', (e) => {
            switchCamera(e.target.value);
        });
        
        function showCameraMode() {
            document.getElementById('cameraSection').classList.add('active');
            setupCamera();
        }
        
        function hideCameraMode() {
            document.getElementById('cameraSection').classList.remove('active');
            if (videoStream) {
                videoStream.getTracks().forEach(track => track.stop());
            }
            document.getElementById('videoPreview').style.display = 'none';
        }
        
        function processCamera() {
            if (!opencvReady) {
                document.getElementById('cameraStatus').textContent = '‚è≥ Loading OpenCV...';
                return;
            }
            
            const video = document.getElementById('videoPreview');
            const processCanvas = document.getElementById('processCanvas');
            processCanvas.width = video.videoWidth;
            processCanvas.height = video.videoHeight;
            
            const ctx2d = processCanvas.getContext('2d');
            ctx2d.drawImage(video, 0, 0);
            
            try {
                const src = cv.imread(processCanvas);
                const gray = new cv.Mat();
                const edges = new cv.Mat();
                
                // Convert to grayscale
                cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
                
                // Detect edges
                cv.Canny(gray, edges, 50, 150);
                
                // Sample edge data to create track curves
                const edgeData = [];
                const step = 20;
                for (let y = 0; y < edges.rows; y += step) {
                    let edgeCount = 0;
                    let totalX = 0;
                    
                    for (let x = 0; x < edges.cols; x++) {
                        if (edges.ucharPtr(y, x)[0] > 128) {
                            edgeCount++;
                            totalX += x;
                        }
                    }
                    
                    if (edgeCount > 0) {
                        const avgX = totalX / edgeCount;
                        const normalizedX = (avgX / edges.cols - 0.5) * 2;
                        edgeData.push(normalizedX);
                    } else {
                        edgeData.push(0);
                    }
                }
                
                // Store camera track data
                cameraTrackData = edgeData;
                
                // Cleanup
                src.delete();
                gray.delete();
                edges.delete();
                
                document.getElementById('cameraStatus').textContent = '‚úÖ Track generated! Starting race...';
                
                setTimeout(() => {
                    startGame('camera');
                }, 1000);
                
            } catch (err) {
                console.error('OpenCV error:', err);
                document.getElementById('cameraStatus').textContent = '‚ùå Error processing image';
            }
        }
        
        // Track configurations
        const tracks = {
            camera: {
                name: 'Camera Track',
                skyColor: '#87CEEB',
                groundColor: '#8FBC8F',
                roadColor: '#333',
                roadLineColor: '#FFFF00',
                grassColor: '#228B22',
                horizonColor: '#5F9EA0'
            },
            desert: {
                name: 'Desert Highway',
                skyColor: '#FFB347',
                groundColor: '#DEB887',
                roadColor: '#333',
                roadLineColor: '#FFD700',
                grassColor: '#C19A6B',
                horizonColor: '#FF8C00'
            },
            city: {
                name: 'City Streets',
                skyColor: '#87CEEB',
                groundColor: '#708090',
                roadColor: '#2F4F4F',
                roadLineColor: '#FFF',
                grassColor: '#696969',
                horizonColor: '#4682B4'
            },
            mountain: {
                name: 'Mountain Pass',
                skyColor: '#B0E0E6',
                groundColor: '#8FBC8F',
                roadColor: '#36454F',
                roadLineColor: '#FFFF00',
                grassColor: '#228B22',
                horizonColor: '#5F9EA0'
            },
            night: {
                name: 'Night City',
                skyColor: '#0A0A2E',
                groundColor: '#1A1A3E',
                roadColor: '#000',
                roadLineColor: '#FFA500',
                grassColor: '#0F0F1E',
                horizonColor: '#1A1A4E'
            }
        };
        
        // Initialize road
        function initRoad() {
            roadSegments = [];
            
            // If using camera track data
            if (currentTrack === 'camera' && cameraTrackData && cameraTrackData.length > 0) {
                for (let i = 0; i < 500; i++) {
                    const dataIndex = i % cameraTrackData.length;
                    const curve = cameraTrackData[dataIndex] * 0.5;
                    const hill = Math.sin(i / 30) * 300;
                    roadSegments.push({
                        index: i,
                        curve: curve,
                        y: hill
                    });
                }
            } else {
                // Standard procedural tracks
                for (let i = 0; i < 500; i++) {
                    const curve = Math.sin(i / 20) * 0.3;
                    const hill = Math.sin(i / 30) * 500;
                    roadSegments.push({
                        index: i,
                        curve: curve,
                        y: hill
                    });
                }
            }
        }
        
        // Initialize traffic cars
        function initCars() {
            cars = [];
            for (let i = 0; i < 20; i++) {
                cars.push({
                    segment: Math.floor(Math.random() * 300) + 50,
                    x: Math.random() * 0.6 + 0.2, // Keep cars on road
                    speed: Math.random() * 50 + 80,
                    color: ['#ff0000', '#0000ff', '#ffff00', '#00ff00', '#ff00ff'][Math.floor(Math.random() * 5)]
                });
            }
        }
        
        // Start game
        function startGame(track) {
            currentTrack = track;
            gameRunning = true;
            gamePaused = false;
            playerX = 0.5;
            speed = 0;
            distance = 0;
            startTime = Date.now();
            
            document.getElementById('menu').classList.add('hidden');
            document.getElementById('hud').classList.add('active');
            document.getElementById('gameOver').classList.remove('active');
            
            // Stop camera if it was running
            if (videoStream) {
                videoStream.getTracks().forEach(track => track.stop());
            }
            
            initRoad();
            initCars();
            gameLoop();
        }
        
        // Pause/Resume
        function pauseGame() {
            if (!gameRunning || gamePaused) return;
            gamePaused = true;
            document.getElementById('pauseMenu').classList.add('active');
        }
        
        function resumeGame() {
            gamePaused = false;
            document.getElementById('pauseMenu').classList.remove('active');
            gameLoop();
        }
        
        function quitToMenu() {
            gameRunning = false;
            gamePaused = false;
            document.getElementById('menu').classList.remove('hidden');
            document.getElementById('hud').classList.remove('active');
            document.getElementById('pauseMenu').classList.remove('active');
            document.getElementById('gameOver').classList.remove('active');
        }
        
        // Game over
        function endRace() {
            gameRunning = false;
            const finalTime = ((Date.now() - startTime) / 1000).toFixed(2);
            document.getElementById('finalTime').textContent = formatTime(finalTime);
            document.getElementById('finalSpeed').textContent = Math.floor(speed);
            document.getElementById('finalDistance').textContent = Math.floor(distance);
            document.getElementById('gameOver').classList.add('active');
        }
        
        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = (seconds % 60).toFixed(0).padStart(2, '0');
            return `${mins}:${secs}`;
        }
        
        // Controls
        window.addEventListener('keydown', e => {
            keys[e.key] = true;
            if (e.key === 'Escape') {
                if (gamePaused) resumeGame();
                else if (gameRunning) pauseGame();
            }
        });
        
        window.addEventListener('keyup', e => {
            keys[e.key] = false;
        });
        
        canvas.addEventListener('touchstart', e => {
            e.preventDefault();
            touchX = e.touches[0].clientX;
        });
        
        canvas.addEventListener('touchmove', e => {
            e.preventDefault();
            touchX = e.touches[0].clientX;
        });
        
        canvas.addEventListener('touchend', () => {
            touchX = null;
        });
        
        // Update game
        function update(dt) {
            if (!gameRunning || gamePaused) return;
            
            // Acceleration
            if (keys['ArrowUp'] || keys['w'] || touchX !== null) {
                speed = Math.min(speed + acceleration * dt, maxSpeed);
            } else {
                speed = Math.max(speed - deceleration * dt, 0);
            }
            
            // Steering
            const currentSegment = roadSegments[Math.floor(distance / segmentLength) % roadSegments.length];
            const baseCurve = currentSegment ? currentSegment.curve * 0.05 : 0;
            
            if (keys['ArrowLeft'] || keys['a']) {
                playerX -= turnSpeed * dt * (1 + Math.abs(baseCurve));
            }
            if (keys['ArrowRight'] || keys['d']) {
                playerX += turnSpeed * dt * (1 + Math.abs(baseCurve));
            }
            
            // Touch steering
            if (touchX !== null) {
                const targetX = touchX / canvas.width;
                const diff = targetX - playerX;
                playerX += diff * turnSpeed * dt * 2;
            }
            
            // Apply curve to player position
            playerX += baseCurve * dt;
            
            // Keep player on road
            playerX = Math.max(0.15, Math.min(0.85, playerX));
            
            // Move forward
            distance += speed * dt;
            
            // Update traffic
            cars.forEach(car => {
                car.segment -= speed * dt / segmentLength;
                if (car.segment < -10) {
                    car.segment = Math.random() * 50 + 300;
                    car.x = Math.random() * 0.6 + 0.2;
                    car.speed = Math.random() * 50 + 80;
                }
                
                // Simple collision detection
                const carDistance = car.segment * segmentLength;
                const distDiff = Math.abs(distance - carDistance);
                if (distDiff < 200 && Math.abs(playerX - car.x) < 0.15) {
                    speed *= 0.5; // Slow down on collision
                }
            });
            
            // Check finish
            if (distance >= finishDistance) {
                endRace();
            }
            
            // Update HUD
            document.getElementById('speed').textContent = Math.floor(speed);
            document.getElementById('distance').textContent = Math.floor(distance);
            document.getElementById('time').textContent = formatTime((Date.now() - startTime) / 1000);
        }
        
        // Render game
        function render() {
            const track = tracks[currentTrack];
            
            // Sky
            ctx.fillStyle = track.skyColor;
            ctx.fillRect(0, 0, canvas.width, canvas.height / 2);
            
            // Ground
            ctx.fillStyle = track.groundColor;
            ctx.fillRect(0, canvas.height / 2, canvas.width, canvas.height / 2);
            
            // Horizon
            ctx.fillStyle = track.horizonColor;
            ctx.fillRect(0, canvas.height / 2 - 50, canvas.width, 100);
            
            // Road segments
            const baseSegment = Math.floor(distance / segmentLength);
            const basePercent = (distance % segmentLength) / segmentLength;
            
            // Render from far to near
            for (let n = 300; n > 0; n--) {
                const segment = roadSegments[(baseSegment + n) % roadSegments.length];
                if (!segment) continue;
                
                // 3D projection
                const camera_x = playerX * roadWidth - roadWidth / 2;
                const camera_y = cameraHeight;
                const camera_z = distance - (n * segmentLength);
                
                const seg_z = (n - basePercent) * segmentLength;
                
                // Project segment
                const scale = cameraDepth / (seg_z + 0.1);
                const projectedWidth = scale * roadWidth * canvas.width / 1000;
                const projectedCenterX = canvas.width / 2 + (scale * segment.curve * roadWidth * 3);
                const projectedY = canvas.height / 2 + (scale * (segment.y - cameraHeight) * 0.5);
                
                if (projectedY < 0 || projectedY > canvas.height) continue;
                
                // Road
                ctx.fillStyle = track.roadColor;
                ctx.fillRect(
                    projectedCenterX - projectedWidth / 2,
                    projectedY,
                    projectedWidth,
                    canvas.height - projectedY
                );
                
                // Grass/sides
                ctx.fillStyle = track.grassColor;
                ctx.fillRect(0, projectedY, projectedCenterX - projectedWidth / 2, canvas.height - projectedY);
                ctx.fillRect(projectedCenterX + projectedWidth / 2, projectedY, canvas.width, canvas.height - projectedY);
                
                // Road lines
                if (n % 5 === 0 && projectedWidth > 50) {
                    ctx.fillStyle = track.roadLineColor;
                    const lineWidth = Math.max(2, projectedWidth * 0.02);
                    ctx.fillRect(
                        projectedCenterX - lineWidth / 2,
                        projectedY,
                        lineWidth,
                        Math.max(2, scale * 50)
                    );
                }
                
                // Draw cars at this segment
                cars.forEach(car => {
                    if (Math.floor(car.segment) === n) {
                        const carProjectedX = projectedCenterX + (car.x - 0.5) * projectedWidth;
                        const carWidth = Math.max(20, projectedWidth * 0.1);
                        const carHeight = Math.max(30, carWidth * 1.5);
                        
                        // Car body
                        ctx.fillStyle = car.color;
                        ctx.fillRect(
                            carProjectedX - carWidth / 2,
                            projectedY - carHeight,
                            carWidth,
                            carHeight
                        );
                        
                        // Car windows
                        ctx.fillStyle = '#87CEEB';
                        ctx.fillRect(
                            carProjectedX - carWidth / 3,
                            projectedY - carHeight * 0.7,
                            carWidth * 0.66,
                            carHeight * 0.4
                        );
                    }
                });
            }
            
            // Draw player car
            const carWidth = 80;
            const carHeight = 120;
            const carX = canvas.width / 2;
            const carY = canvas.height - carHeight - 50;
            
            // Shadow
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.fillRect(carX - carWidth / 2 + 5, carY + carHeight - 10, carWidth, 10);
            
            // Car body
            ctx.fillStyle = '#ff0000';
            ctx.fillRect(carX - carWidth / 2, carY, carWidth, carHeight);
            
            // Car details
            ctx.fillStyle = '#87CEEB';
            ctx.fillRect(carX - carWidth / 3, carY + 20, carWidth * 0.66, carHeight * 0.3);
            
            // Racing stripes
            ctx.fillStyle = '#fff';
            ctx.fillRect(carX - 10, carY, 4, carHeight);
            ctx.fillRect(carX + 6, carY, 4, carHeight);
            
            // Finish line
            if (distance > finishDistance - 1000) {
                const finishDist = finishDistance - distance;
                if (finishDist > 0) {
                    const finishN = finishDist / segmentLength;
                    const finishScale = cameraDepth / (finishN * segmentLength + 0.1);
                    const finishY = canvas.height / 2;
                    
                    if (finishY > 0 && finishY < canvas.height) {
                        ctx.fillStyle = '#fff';
                        ctx.font = 'bold 40px Courier New';
                        ctx.textAlign = 'center';
                        ctx.fillText('FINISH', canvas.width / 2, finishY);
                    }
                }
            }
        }
        
        // Game loop
        let lastTime = Date.now();
        function gameLoop() {
            if (!gameRunning || gamePaused) return;
            
            const now = Date.now();
            const dt = Math.min((now - lastTime) / 1000, 0.1); // Delta time in seconds
            lastTime = now;
            
            update(dt);
            render();
            
            requestAnimationFrame(gameLoop);
        }
    </script>
</body>
</html>
